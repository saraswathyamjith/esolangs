# -*- coding: utf-8 -*-
"""0815eval.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OYkowC4G5on9a3rYezHYnll-uMNNyVUs
"""

!wget -O /content/esolang0815_interpreter.py "https://gist.githubusercontent.com/perey/015aeea5c3af016531e9/raw/71b4cbfd16577e349d58a11eefd1cde12d40a2ae/esolang0815_interpreter.py"

documentation = """
Â¤0815

0815 - Language details

0815 is based around a queue and 3 registers. It understands hexadecimals only, so every numeric input and output are in hexadecimals. It also ignores everything that is not one of its instructions, for that matter: everything that is not an instruction is a comment.
Registers

0815 has 3 signed integers 64 bit wide registers: X, Y, and Z. All three are initialized with 0. X is a write only register and Z is a read only register. Y is a helper register and cannot be accessed by the programmer.
Parameters

Some of 0815 instructions need parameters. All parameters must be surrounded by colons, e.g. :3c:
Labels are also considered parameters; therefore they also need the surrounding colons.
If a parameter is needed but any is found the instruction will simply be ignored, no error message will be displayed.
Jumps

In 0815 you find 2 kinds of jumps: if Zero( # ) or if not Zero( ^ ). Jumps' labels can contain any character, except the language reserved symbols, e.g. :_loop: or :34:
If the label that the jump is pointed to is not found, the program terminates.
New lines

Either ASCII 10 or 13 will be interpreted as a new line.
Instructions

+-----------+---------+---------------------------------------------------------------------------+
|           |         |<:2: will move '2' to register X                                           |
|   move    |    <    |(parameter is mandatory)                                                   |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|           |         |swaps register X and Y                                                     |
|   swap    |    x    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|           |         |}:_loop: this creates a label called '_loop'                               |
|   label   |    }    |(parameter is mandatory)                                                   |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   input   |         |inputs a signed 64 bit integer and stores it into X                        |
|   number  |    |    |(hexadecimal base)                                                         |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   input   |         |inputs an ASCII char and stores it into X                                  |
|   ASCII   |    !    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   print   |         |prints a signed 64 bit integer stored in Z                                 |
|   number  |    %    |(hexadecimal base)                                                         |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   print   |         |prints an ASCII char stored in Z                                           |
|   ASCII   |    $    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   roll    |         |rolls all registers to the left: X <- Y <- Z                               |
| registers |    ~    |after roll: X = Y, Y = Z and Z = X                                         |
|   left    |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   roll    |         |rolls all registers to the right: X -> Y -> Z                              |
| registers |    =    |after roll: X = Z, Y = X and Z = Y                                         |
|  right    |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   jump    |         |^:_loop: jumps to label _loop if Z is not 0                                |
|   if not  |    ^    |(parameter is mandatory)                                                   |
|   zero    |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   jump    |         |#:_loop: jumps to label _loop if Z is 0                                    |
|   if      |    #    |(parameter is mandatory)                                                   |
|   zero    |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
Queue instructions

+-----------+---------+---------------------------------------------------------------------------+
|           |         |clears the queue                                                           |
|  clear    |    ?    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|           |         |enqueue the number stored in Z                                             |
|  enqueue  |    >    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|           |         |dequeue a number and stores it into X                                      |
|  dequeue  |    {    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|   roll    |         |rolls the queue to the left: the first value becomes the last, the second  |
|   queue   |    @    |will be first and so on. If no parameter is found, it will roll the queue  |
|   left    |         |once, otherwise rolls it parameter times. e.g. @:a: rolls the queue ten    |
|           |         |times to the left.                                                         |
+-----------+---------+---------------------------------------------------------------------------+
|  roll     |         |the same as '@' just that the roll will go to the right:                   |
|  queue    |    &    |the last will be the first, the first will be the second and so on.        |
|  right    |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
Arithmetic instructions

+-----------+---------+---------------------------------------------------------------------------+
|           |         |Z = X + Y                                                                  |
|   add     |    +    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|           |         |Z = X - Y                                                                  |
|   sub     |    -    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|           |         |Z = X * Y                                                                  |
| multipl.  |    *    |                                                                           |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
|           |         |Z = X / Y                                                                  |
| division  |    /    |Y = rest                                                                   |
|           |         |                                                                           |
+-----------+---------+---------------------------------------------------------------------------+
Interpreter

I re-wrote my Brainfuck interpreter to run 0815 programs. This version just runs (interprets) 0815 programs.
Probably, I'll write another version that can interpret both languages, but for now, this will do.
There is another issue that I should mention: In this version, the Queue will only show its first 2070 items.
0815 Interpreter

0815 Programming examples

Hello World!
Cat
Odd or Even
Binary representation of an integer
Factorial sequence (0 - 14h)
Arithmetic mean(averages)
Fibonacci sequence (0 - a94fad42221f2702h)
99 bottles of beer (63h bottles of beer)
Prime numbers
Hailstone sequence
Simple randomizer
Sum of squares
Truth machine - numeric
Truth machine - ASCII

Home | Esolang

"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# Program definitions
hello_world_program = """
<:48:x<:65:=<:6C:$=$=$$~<:03:+$~<:ffffffffffffffbd:+$<:ffffffffffffffb1:
+$<:57:~$~<:18:x+$~<:03:+$~<:06:x-$x<:0e:x-$=x<:43:x-$
"""

cat_program = """
}:_t:!~$^:_t:
"""

odd_even_program = """
}:s:|=<:2:x~#:e:=/~%~<:20:~$=<:73:x<:69:~$~$~<:20:~$=^:o:<:65:
x<:76:=$=$~$<:6E:~$<:a:~$^:s:}:o:<:6F:x<:64:x~$~$$<:a:~$^:s:
"""

binary_program = """
|~}:z:=x<:2:x/=>&~^:z:
<:ffffffffffffffff:~>}:s:{x
<:ffffffffffffffff:
-#:out:=%~^:s:
"""

factorial_program = """
<:1:~%<:d:~$~>~}:s:><:1:x{+>~{*%
<:21C3677C82B40000:=-#:end:~<:d:~$=^:s:
"""

arithmetic_program = """
<:01:~><:02:~><:03:~><:04:~><:05:~><:06:~><:07:~><:08:~><:09:~>
<:0a:~><:0b:~><:0c:~><:0d:~><:0e:~><:0f:~><:10:~><:11:~><:12:~>
<:13:~><:14:~><:15:~><:16:~><:17:~><:18:~><:19:~><:ffffffffffffffff:~>
{x{+>}:8f:{&={+>{~>&=x<:ffffffffffffffff:/#:8f:{{=<:19:x/%
"""

fibonacci_program = """
# %<:0D:>~$<:01:~%>=<:a94fad42221f2702:>~>}:_s:{x{={~$x+%{=>~>x~-x<:0D:~>~>~^:_s:?
"""

prime_program = """
<:2:~}:strt:>~}:net:<:1:x-~<:1:x-#:ok:x{=>=>=/=#:nP:{x
^:net:}:ok:{~%<:d:~$<:1:+^:strt:}:nP:{{x<:1:+^:strt:
"""

hailstone_program = """
|~}:s:%~<:1:-#:end:
<:d:~$~>{>x<:2:x/=
#:evn:{x<:3:*~<:1:+
^:s:}:evn:~{^:s:
"""

sum_of_squares_program = """
{x{*%<:d:~$<:1:~>><:2:~>><:3:~>><:4:~>><:5:~>><:6:~>><:7:
~>><:8:~>><:9:~>><:a:~>><:b:~>><:c:~>><:ffffffffffffffff:
~>{x{*>}:8f:{x{*&{=+>{~>&=x<:ffffffffffffffff:/#:8f:{{~%
"""

# Read the 99bb.0815 file content
file_path = '/content/drive/MyDrive/99bb.0815'
with open(file_path, 'r') as file:
    program99 = file.read()

# Combine all programs into documentation
documentation += f"""
--- Hello World Program ---
{hello_world_program}

--- Cat Program ---
{cat_program}

--- Odd Even Program ---
{odd_even_program}

--- Binary Program ---
{binary_program}

--- Factorial Program ---
{factorial_program}

--- Arithmetic Program ---
{arithmetic_program}

--- Fibonacci Program ---
{fibonacci_program}

--- Prime Program ---
{prime_program}

--- Hailstone Program ---
{hailstone_program}

--- Sum of Squares Program ---
{sum_of_squares_program}

--- 99bb Program ---
{program99}
"""

# Save in context documentation to a file
with open('/content/drive/MyDrive/0815examples.txt', 'w') as doc_file:
    doc_file.write(documentation)

with open("/content/hello_world.0815", "w") as file:
    file.write(hello_world_program)


with open("/content/catprogram.0815", "w") as file:
    file.write(cat_program)


with open("/content/oddeven.0815", "w") as file:
    file.write(odd_even_program)

!python3 /content/esolang0815_interpreter.py /content/hello_world.0815

!echo "10" | python3 /content/esolang0815_interpreter.py /content/oddeven.0815

!echo "10" | python3 /content/esolang0815_interpreter.py /content/catprogram.0815

import openai
import os
import os
import subprocess
import re
from openai import OpenAI

# Uncomment the line below and replace 'your-api-key' with your actual API key
os.environ["OPENAI_API_KEY"] = 'your-api-key'
results = []
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# Prompt engineered prompt
def mod_prompt(prompt):
   modified_prompt = (
        f"Write a function in Pyth, an esoteric programming language."
        f"The function should perform the following: {prompt}"
        f"The documentation for Pyth is provided here: '{text_content}'. "

    )
   return modified_prompt

# Commented out IPython magic to ensure Python compatibility.
# collects human eval problems from github
!git clone https://github.com/openai/human-eval.git
# %cd human-eval
!ls data
!gunzip data/HumanEval.jsonl.gz
!ls data
!pip install transformers torch jsonlines
import jsonlines

problems = []

# Load the problems from the JSONL file
with jsonlines.open("data/HumanEval.jsonl") as f:
    for obj in f:
        problems.append(obj)

from typing import List, Tuple, Any
import ast

# Path to your local 0815 interpreter
eso_INTERPRETER_PATH = "/content/esolang0815_interpreter.py"

def execute_0815_function(code: str, input_data: Any = "") -> str:
    """
    Executes Pyth code with the given input and returns the output or a concise error message.
    """
    try:
        if not os.path.isfile(eso_INTERPRETER_PATH):
            return f"Error: Pyth interpreter not found at {eso_INTERPRETER_PATH}."

        temp_eso_path = "temp.0815"
        with open(temp_eso_path, "w") as f:
            f.write(code)

        input_str = str(input_data)

        result = subprocess.run(
            ["python3", eso_INTERPRETER_PATH, temp_eso_path],
            input=input_str,
            capture_output=True,
            text=True,
            timeout=5
        )

        if result.returncode != 0:
            error_message = result.stderr.strip().split('\n')[-1]
            return f"Error: {error_message}"

        return result.stdout.strip()

    except subprocess.TimeoutExpired:
        return "Error: Execution timed out."
    except Exception as e:
        return f"Error during execution: {str(e)}"

def extract_0815_code(generated_content: str) -> str:
    """
    Extracts the first 0815 code block from the generated content.
    Handles code blocks enclosed with ``` or ''' and marked as plaintext or 0815.
    If the closing delimiter is missing, captures until the end of the string.

    Args:
        generated_content (str): The content containing code blocks.

    Returns:
        str: The extracted 0815 code if found, else an empty string.
    """
    # Define a regex pattern that matches both ``` and ''' as delimiters
    # and captures code blocks marked as plaintext or 0815
    pattern = r"""
        (?P<delimiter>```|''')
        (?P<lang>plaintext|0815)?\s*\n?
        (?P<code>[\s\S]*?)(?:(?P=delimiter)|$)
    """

    regex = re.compile(pattern, re.VERBOSE | re.IGNORECASE)

    matches = regex.finditer(generated_content)

    for match in matches:
        lang = match.group('lang')
        code = match.group('code')
        if lang and lang.lower() in ['plaintext', '0815']:
            return code.strip()

    return ""


def parse_test_cases(test_str: str) -> List[Tuple[Any, Any]]:
    """
    Parses a string containing Python assert statements to extract test cases.
    Returns a list of tuples: (input_args, expected_output).
    """
    test_cases = []

    # Patterns for different assert types
    pattern_eq = re.compile(
        r'assert\s+candidate\((.*?)\)\s*==\s*('
        r'\[.*?\]|True|False|None|".*?"|\'.*?\'|[-+]?\d*\.\d+|\d+'
        r')',
        re.DOTALL
    )
    pattern_approx_eq = re.compile(
        r'assert\s+abs\s*\(\s*candidate\((.*?)\)\s*-\s*(.*?)\s*\)\s*<\s*('
        r'[-+]?\d*\.\d+|\d+'
        r')',
        re.DOTALL
    )

    # Extract direct equality test cases
    for args_str, expected_str in pattern_eq.findall(test_str):
        try:
            input_args = ast.literal_eval(args_str.strip())
            expected_output = ast.literal_eval(expected_str.strip())
            test_cases.append((input_args, expected_output))
        except Exception as e:
            print(f"Error parsing direct equality test case: {e}")

    # Extract approximate equality test cases
    for args_str, expected_str, tolerance_str in pattern_approx_eq.findall(test_str):
        try:
            input_args = ast.literal_eval(args_str.strip())
            expected_output = ast.literal_eval(expected_str.strip())
            test_cases.append((input_args, expected_output))
        except Exception as e:
            print(f"Error parsing approximate equality test case: {e}")

    return test_cases

def mod_prompt(prompt: str, feedback: str = "") -> str:
    """
    Modifies the prompt by including feedback from previous attempts.
    """
    if feedback:
        modified_prompt = (
            f"Write a function in 0815 an esoteric programming language. "
            f"The function should perform the following: {prompt} "
            f"The documentation for 0815 is provided here: '{documentation}'. "
            f"Here is the feedback from the previous attempt: {feedback}"
        )
    else:
        modified_prompt = (
            f"Write a function in 0815, an esoteric programming language. "
            f"The function should perform the following: {prompt} "
            f"The documentation for 0815 is provided here: '{documentation}'. "
        )
    return modified_prompt

# Evaluation Loop with Retry for 2-shotting purposes

results = []
max_retries = 2  # Maximum number of attempts per problem

for idx, problem in enumerate(problems[:10]):
    print(f"\nEvaluating Problem {idx+1}/{len(problems)}: {problem['task_id']}")
    attempt = 0
    success = False
    feedback = ""

    while attempt < max_retries and not success:
        print(f"Attempt {attempt + 1} for Problem {problem['task_id']}")

        try:
            # Generate 0815 code using OpenAI API
            response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages = [
    {
        "role": "system",
        "content": (
            f"You are an assistant that writes 0815, the esolang, code. "
            f"The documentation for 0815 {documentation} is provided here. "
        ),
    },
    {
        "role": "user",
        "content": mod_prompt(problem['prompt']),
    }
],
            temperature=0.0,  # Lower temperature for deterministic output
            max_tokens=500  # Adjust based on expected code length
        )
            generated_content = response.choices[0].message.content.strip()
            print(f"Generated Content:\n{generated_content[:500]}...\n")

            # Extract 0815 code from the generated content
            eso_code = extract_0815_code(generated_content)
            print(f"Extracted 0815 Code:\n{eso_code}\n")

            if not eso_code:
                raise ValueError("No 0815 code found in the response.")

            # Parse test cases
            parsed_test_cases = parse_test_cases(problem['test'])
            print(f"Parsed Test Cases: {parsed_test_cases}\n")

            # Initialize pass status
            all_pass = True
            failed_tests = []

            # Execute and evaluate each test case
            for test_idx, (inputs, expected) in enumerate(parsed_test_cases, start=1):
                output = execute_0815_function(eso_code, inputs)

                # Limit the output printed to prevent long error messages
                if output.startswith("Error:"):
                    display_output = output  # Short error message
                else:
                    display_output = output[:20] + "..." if len(output) > 20 else output  # Truncate long outputs

                print(f"Test {test_idx}: Input: {inputs}, Expected: {expected}, Output: {display_output}")

                pass_test = (str(expected) in output)
                if not pass_test:
                    all_pass = False
                    failed_tests.append({
                        "test_idx": test_idx,
                        "input": inputs,
                        "expected": expected,
                        "output": output
                    })
                print(f"Pass: {pass_test}\n")

            if all_pass:
                print(f"Problem {problem['task_id']} passed all test cases.")
                results.append({
                    "problem": problem["task_id"],
                    "status": "Passed",
                    "attempts": attempt + 1
                })
                success = True
            else:
                print(f"Problem {problem['task_id']} failed some test cases.")

                failed_test_descriptions = [
                    f"Test {ft['test_idx']}: Expected {ft['expected']}, Got {ft['output']}"
                    for ft in failed_tests
                ]
                feedback = f"The following test cases failed: {'; '.join(failed_test_descriptions)}"
                attempt += 1

        except Exception as e:
            print(f"Error during evaluation: {e}")
            feedback = f"Encountered an error: {e}"
            attempt += 1

    if not success:
        print(f"Problem {problem['task_id']} failed after {max_retries} attempts.")
        results.append({
            "problem": problem["task_id"],
            "status": "Failed",
            "attempts": attempt
        })

print("\nFinal Results:")
totalpassed = 0
for res in results:
    print(f"Problem: {res['problem']}, Status: {res['status']}, Attempts: {res['attempts']}")
    if res['status'] == True:
         totalpassed += 1

print("percentage passed: " + str(100*totalpassed/ len(results)) + "%")
